for (t in types){
# kilodaltons to grams: 1 kDa = 1.66054e-21 g and g to pg: 1 g = 1e12 pg
data[[t]] <- data[[t]] |>
# add column for protein amount in picograms/cell
mutate(amount_pg_per_cell = (copy_number*mw_kDa*1e12)/N_A)
}
for (t in types){
cat(paste0(t, ": \n"))
# print total number of protein molecules per cell
total_protein_molecules_per_cell <- sum(data[[t]]$copy_number)
cat(paste0("Number of molecules per cell: ", total_protein_molecules_per_cell,"\n"))
# print total protein amount per cell
total_protein_amount_per_cell <- sum(data[[t]]$amount_pg_per_cell)
cat(paste0("Total protein amount per cell (pg): ", total_protein_amount_per_cell,"\n"))
# print cell volume
# Assumption from Perseus: Total cellular protein concentration is 200 g/l
cell_volume <- total_protein_amount_per_cell / (200*1e12)
cat(paste0("Cell volume (pL): ", cell_volume*1e12,"\n","\n"))
}
# proteins of interest
# PTK2: gene name for focal adhesion kinase 1
# PI3K: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3937771/ suggests Class I type for PI(4,5)P2 to PI(3,4,5)P3. For class I, subunits of interest are PIK3C{A,B,D,G}, PIK3R{1,2,3,5,6}
# dataset only has PIK3CA, PIK3CB, PIK3R1, and PIK3R2
# Another name for Rabin8: RAB3IP
# Akt1 or Akt2 or both: mostly like just add them up to get Akt
# Maybe just go ahead with Rab8A, considering the following line in NCB paper
# "Short hairpin RNAs (shRNAs) for human Rab8a (target sequence: AACAAGT- GTGATGTGAATGAC)"
# Rab8 GAP: TBC1D17 (https://www.uniprot.org/uniprotkb/Q9HA65/entry)
proteins_of_interest <- c("PTK2", "PIK3CA", "PIK3CB", "PIK3R1", "PIK3R2",
"PTEN", "AKT1", "AKT2", "RAB3IP", "RAB8A", "RAB8B", "TBC1D17")
data_filtered <- data[["histone_with_detectability_correction"]] |>
filter(gene %in% proteins_of_interest) |>
select(all_of(c("gene","conc_nM","copy_number","quant_accuracy","unique_peptides"))) |>
mutate(conc_0.1pl = 10^21 * copy_number/(0.1*N_A)) |>
mutate(conc_0.5pl = 10^21 * copy_number/(0.5*N_A)) |>
mutate(conc_1pl = 10^21 * copy_number/(N_A)) |>
mutate(conc_5pl = 10^21 * copy_number/(5*N_A)) |>
mutate(conc_10pl = 10^21 * copy_number/(10*N_A))
# load excel file with specific sheet named "proteinGroups" and don't show warnings
data_other_cell_lines <- readxl::read_excel("proteome_ruler_paper_SuppTab2.xlsx",
sheet = "proteinGroups") |>
as_tibble()
# keep only the columns with subscript "Copy number" or "Gene names" in their name
cols_to_keep <- grep("Copy number|Gene names", colnames(data_other_cell_lines), value = TRUE)
data_other_cell_lines <- data_other_cell_lines |>
select(all_of(cols_to_keep))
# remove substring "Copy number" from column names that have it
colnames(data_other_cell_lines)[1:12] <- gsub("Copy number ", "",
colnames(data_other_cell_lines)[1:12])
colnames(data_other_cell_lines)[13] <- "gene"
# keep only the proteins of interest
data_other_cell_lines <- data_other_cell_lines |>
filter(gene %in% proteins_of_interest) |>
column_to_rownames(var = "gene") |>
# mutate all the columns to numeric
mutate(across(everything(), as.numeric)) |>
# mutate all columns by dividing by N_A
# assuming 1pL cell volume and converting to nM
mutate(across(everything(), ~ ./(N_A*1e-21))) |>
rownames_to_column(var = "gene")
compare_cell_lines <- data_filtered |>
select(all_of(c("gene", "conc_1pl"))) |>
inner_join(data_other_cell_lines, by = "gene") |>
# round off all the numerics to 2 decimal places
mutate(across(where(is.numeric), ~ round(., 2)))
View(data_filtered)
View(data_other_cell_lines)
View(compare_cell_lines)
load("~/Desktop/PhD/diao_wgs/Figures/fold_change/my_anno/featurecount.RData")
BiocManager::install("CMplot")
library(CMplot)
setwd("~/Desktop/PhD/diao_wgs/Figures/fold_change/my_anno")
suppressPackageStartupMessages({
library(tidyverse)
library(edgeR)
library(CMplot)
})
# load featurecount.RData
load("featurecount.RData")
# extract count data
counts <- fc$counts %>%
as_tibble()
# convert NC<> to chr<>
# chr1 - NC_000067.7
# chr2 - NC_000068.8
# chr3 - NC_000069.7
# chr4 - NC_000070.7
# chr5 - NC_000071.7
# chr6 - NC_000072.7
# chr7 - NC_000073.7
# chr8 - NC_000074.7
# chr9 - NC_000075.7
# chr10 - NC_000076.7
# chr11 - NC_000077.7
# chr12 - NC_000078.7
# chr13 - NC_000079.7
# chr14 - NC_000080.7
# chr15 - NC_000081.7
# chr16 - NC_000082.7
# chr17 - NC_000083.7
# chr18 - NC_000084.7
# chr19 - NC_000085.7
# chrX - NC_000086.8
# chrY - NC_000087.8
# chrMT - NC_005089.1
counts$Chr <- gsub("NC_000067.7", "chr1", counts$Chr)
View(counts)
View(fc$counts)
# extract count data
counts <- fc$counts %>%
rownames_to_column(var = "geneID") %>%
separate(col = "geneID", into = "Chr", sep = "-")
# extract count data
counts <- fc$counts |>
as.data.frame() |>
rownames_to_column(var = "geneID") |>
separate(col = "geneID", into = "Chr", sep = "-")
View(counts)
# extract count data
counts <- fc$counts |>
as.data.frame() |>
rownames_to_column(var = "geneID") |>
separate(col = "geneID", into = c("Bin","Chromosome","Start","End"), sep = "-") |>
mutate(Position = mean(Start, End))
view(fc$annotation)
# load tidyr and suppress messages
suppressMessages(library(tidyverse))
# types of data
types <- c("histone_with_detectability_correction", "histone_no_detectability_correction", "tpa_with_detectability_correction", "tpa_no_detectability_correction")
# define an empty named list for storing data
data <- setNames(vector("list", length(types)), types)
# load data
for (t in types){
data[[t]] <- read.table(paste0(t, ".txt"), sep = '\t', header = TRUE)
}
colnames(data[[types[1]]])
# keep only the columns that are needed
for (t in types){
data[[t]] <- data[[t]][, c(19, 18, 16, 15, 9, 8, 5)] |>
as_tibble()
}
colnames(data[[types[1]]])
# rename the columns
for (t in types){
colnames(data[[t]]) <- c("gene", "protein", "conc_nM", "copy_number", "mw_kDa", "unique_peptides", "quant_accuracy")
}
# avagadro's number
N_A <- 6.022e23
for (t in types){
# kilodaltons to grams: 1 kDa = 1.66054e-21 g and g to pg: 1 g = 1e12 pg
data[[t]] <- data[[t]] |>
# add column for protein amount in picograms/cell
mutate(amount_pg_per_cell = (copy_number*mw_kDa*1e12)/N_A)
}
for (t in types){
cat(paste0(t, ": \n"))
# print total number of protein molecules per cell
total_protein_molecules_per_cell <- sum(data[[t]]$copy_number)
cat(paste0("Number of molecules per cell: ", total_protein_molecules_per_cell,"\n"))
# print total protein amount per cell
total_protein_amount_per_cell <- sum(data[[t]]$amount_pg_per_cell)
cat(paste0("Total protein amount per cell (pg): ", total_protein_amount_per_cell,"\n"))
# print cell volume
# Assumption from Perseus: Total cellular protein concentration is 200 g/l
cell_volume <- total_protein_amount_per_cell / (200*1e12)
cat(paste0("Cell volume (pL): ", cell_volume*1e12,"\n","\n"))
}
library(kableExtra)
# load tidyr and suppress messages
suppressMessages({
library(tidyverse)
library(kableExtra)
})
# keeping only the proteins of interest, and copy_number and amount_pg_per_cell columns
# output data[[1]] using kable
data[["histone_with_detectability_correction"]] |>
filter(gene %in% proteins_of_interest) |>
select(all_of(c("gene", "conc_1pl", "copy_number", "amount_pg_per_cell"))) |>
kable("html", escape = FALSE) |>
cat()
# proteins of interest
# PTK2: gene name for focal adhesion kinase 1
# PI3K: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3937771/ suggests Class I type for PI(4,5)P2 to PI(3,4,5)P3. For class I, subunits of interest are PIK3C{A,B,D,G}, PIK3R{1,2,3,5,6}
# dataset only has PIK3CA, PIK3CB, PIK3R1, and PIK3R2
# Another name for Rabin8: RAB3IP
# Akt1 or Akt2 or both: mostly like just add them up to get Akt
# Maybe just go ahead with Rab8A, considering the following line in NCB paper
# "Short hairpin RNAs (shRNAs) for human Rab8a (target sequence: AACAAGT- GTGATGTGAATGAC)"
# Rab8 GAP: TBC1D17 (https://www.uniprot.org/uniprotkb/Q9HA65/entry)
proteins_of_interest <- c("PTK2", "PIK3CA", "PIK3CB", "PIK3R1", "PIK3R2",
"PTEN", "AKT1", "AKT2", "RAB3IP", "RAB8A", "RAB8B", "TBC1D17")
data_filtered <- data[["histone_with_detectability_correction"]] |>
filter(gene %in% proteins_of_interest) |>
select(all_of(c("gene","conc_nM","copy_number","quant_accuracy","unique_peptides"))) |>
mutate(conc_0.1pl = 10^21 * copy_number/(0.1*N_A)) |>
mutate(conc_0.5pl = 10^21 * copy_number/(0.5*N_A)) |>
mutate(conc_1pl = 10^21 * copy_number/(N_A)) |>
mutate(conc_5pl = 10^21 * copy_number/(5*N_A)) |>
mutate(conc_10pl = 10^21 * copy_number/(10*N_A))
# keeping only the proteins of interest, and copy_number and amount_pg_per_cell columns
# output data[[1]] using kable
data[["histone_with_detectability_correction"]] |>
filter(gene %in% proteins_of_interest) |>
select(all_of(c("gene", "conc_1pl", "copy_number", "amount_pg_per_cell"))) |>
kable("html", escape = FALSE) |>
cat()
# keeping only the proteins of interest, and copy_number and amount_pg_per_cell columns
# output data[[1]] using kable
data[["histone_with_detectability_correction"]] |>
filter(gene %in% proteins_of_interest) |>
select(all_of(c("gene", "copy_number", "amount_pg_per_cell"))) |>
kable("html", escape = FALSE) |>
cat()
# keeping only the proteins of interest, and copy_number and amount_pg_per_cell columns
# output data[[1]] using kable
data[["histone_with_detectability_correction"]] |>
filter(gene %in% proteins_of_interest) |>
select(all_of(c("gene", "copy_number", "amount_pg_per_cell"))) |>
kable()
# keeping only the proteins of interest, and copy_number and amount_pg_per_cell columns
# output data[[1]] using kable
data[["histone_with_detectability_correction"]] |>
filter(gene %in% proteins_of_interest) |>
select(all_of(c("gene", "copy_number", "amount_pg_per_cell"))) |>
kable("html")
?kable
# keeping only the proteins of interest, and copy_number and amount_pg_per_cell columns
# output data[[1]] using kable
data[["histone_with_detectability_correction"]] |>
filter(gene %in% proteins_of_interest) |>
select(all_of(c("gene", "copy_number", "amount_pg_per_cell"))) |>
kable("simple")
# keeping only the proteins of interest, and copy_number and amount_pg_per_cell columns
# output data[[1]] using kable
data[["histone_with_detectability_correction"]] |>
filter(gene %in% proteins_of_interest) |>
select(all_of(c("gene", "copy_number", "amount_pg_per_cell"))) |>
kable("jira")
# keeping only the proteins of interest, and copy_number and amount_pg_per_cell columns
# output data[[1]] using kable
data[["histone_with_detectability_correction"]] |>
filter(gene %in% proteins_of_interest) |>
select(all_of(c("gene", "copy_number", "amount_pg_per_cell"))) |>
kable("rst")
# keeping only the proteins of interest, and copy_number and amount_pg_per_cell columns
# output data[[1]] using kable
data[["histone_with_detectability_correction"]] |>
filter(gene %in% proteins_of_interest) |>
select(all_of(c("gene", "copy_number", "amount_pg_per_cell"))) |>
kable("org")
# keeping only the proteins of interest, and copy_number and amount_pg_per_cell columns
# output data[[1]] using kable
data[["histone_with_detectability_correction"]] |>
filter(gene %in% proteins_of_interest) |>
select(all_of(c("gene", "copy_number", "amount_pg_per_cell"))) |>
kable("pipe")
# load tidyr and suppress messages
suppressMessages({
library(tidyverse)
library(kableExtra)
library(gt)
})
# keeping only the proteins of interest, and copy_number and amount_pg_per_cell columns
# output data[[1]] using kable
data[["histone_with_detectability_correction"]] |>
filter(gene %in% proteins_of_interest) |>
select(all_of(c("gene", "copy_number", "amount_pg_per_cell"))) |>
gt()
# keeping only the proteins of interest, and copy_number and amount_pg_per_cell columns
# output data[[1]] using kable
temp <- data[["histone_with_detectability_correction"]] |>
filter(gene %in% proteins_of_interest) |>
select(all_of(c("gene", "copy_number", "amount_pg_per_cell")))
View(temp)
View(data_filtered)
# load excel file with specific sheet named "proteinGroups" and don't show warnings
data_other_cell_lines <- readxl::read_excel("proteome_ruler_paper_SuppTab2.xlsx",
sheet = "proteinGroups") |>
as_tibble()
# keep only the columns with subscript "Copy number" or "Gene names" in their name
cols_to_keep <- grep("Copy number|Gene names", colnames(data_other_cell_lines), value = TRUE)
data_other_cell_lines <- data_other_cell_lines |>
select(all_of(cols_to_keep))
# remove substring "Copy number" from column names that have it
colnames(data_other_cell_lines)[1:12] <- gsub("Copy number ", "",
colnames(data_other_cell_lines)[1:12])
colnames(data_other_cell_lines)[13] <- "gene"
# keep only the proteins of interest
data_other_cell_lines <- data_other_cell_lines |>
filter(gene %in% proteins_of_interest) |>
column_to_rownames(var = "gene") |>
# mutate all the columns to numeric
mutate(across(everything(), as.numeric)) |>
# mutate all columns by dividing by N_A
# assuming 1pL cell volume and converting to nM
mutate(across(everything(), ~ ./(N_A*1e-21))) |>
rownames_to_column(var = "gene")
compare_cell_lines <- data_filtered |>
select(all_of(c("gene", "conc_1pl"))) |>
inner_join(data_other_cell_lines, by = "gene") |>
# round off all the numerics to 2 decimal places
mutate(across(where(is.numeric), ~ round(., 2)))
View(compare_cell_lines)
X = matrix(0, 100, 2)
X[,1] = rep(1, 100)
sep(0, 1, 100)
X[,2] = seq(0,1, 100)
P = X * solve(X^T * X) * X^T
P = X %*% solve(X^T %*% X) %*% X^T
P = X %*% solve(t(X) %*% X) %*% t(X)
X
seq(0,1, 100)
?seq
X[,2] = seq(0,1, length.out = 100)
X
P = X %*% solve(t(X) %*% X) %*% t(X)
eigen(P)
X = matrix(0, 10, 2)
X[,1] = rep(1, 100)
X[,1] = rep(1, 10)
X[,2] = seq(0,1, length.out = 10)
P = X %*% solve(t(X) %*% X) %*% t(X)
eigen(P)
values, vectors <- eigen(P)
[values, vectors] <- eigen(P)
temp <- eigen(P)
temp['values']
D <- diag(temp$values)
View(D)
Q = cind(temp$vectors)
Q = cbind(temp$vectors)
(P == Q %*% D %*% t(Q))
View(Q)
temp$vectors[1]
temp$vectors
Q = temp$vectors
P %*% Q[,1]
P %*% Q[,3]
Q %*% t(Q)
view(round(Q %*% t(Q), 1))
View(round(Q %*% t(Q), 1))
View(round(t(Q) %*% Q, 1))
View(round(Q[,c(1,2)] %*% t(Q[,c(1,2)]), 1))
Q[,1:2]
View(round(Q[,1:2] %*% t(Q[,1:2]), 1))
View(round(t(Q[,1:2]) %*% Q[,1:2], 1))
# load the packages -------
suppressPackageStartupMessages({
library(tidyverse)
library(kableExtra)
})
# set the working directory as the location of the script -------
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# global features -------
features <- c("area", "circularity", "aspect_ratio",
"cell_stiffness", "motility")
# load the data --------
# define an empty named list for storing data
data <- setNames(vector("list", length(features)), features)
for (f in features){
data[[f]] <- read_tsv(paste('../data/',f,'.tsv',sep = ''),
show_col_types = FALSE) %>% as_tibble()
colnames(data[[f]]) <- c("cl_id", "sub_id", "feature_value")
data[[f]] <- data[[f]] %>%
mutate_at(c('cl_id', 'sub_id'), as.factor)
}
# Count the number of measurements -----
counts <- setNames(vector("list", length(features)), features)
for (f in features){
counts[[f]] <- data[[f]] %>%
group_by(cl_id, sub_id) %>%
summarise(n = n()) %>%
ungroup() %>%
arrange(cl_id, sub_id) %>%
# pivot to wider
pivot_wider(names_from = sub_id, values_from = n) %>%
# make cl_id to rownames
column_to_rownames(var = "cl_id")
}
# save the counts as a latex table -------
for (i in 1:length(features)){
counts[[features[i]]] |>
kable(
format = "latex",
align = "c",
caption = "",
label = paste("count-", features[i]),
booktabs = TRUE,
escape = FALSE
) |>
kable_styling(latex_options = "hold_position") |>
save_kable(paste0("supplementary_table_", i, ".tex"))
}
# load the packages -------
suppressPackageStartupMessages({
library(tidyverse)
library(kableExtra)
})
# set the working directory as the location of the script -------
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# global parameters -------
features <- c("area", "circularity", "aspect_ratio",
"cell_stiffness", "motility")
cell.line.names <-  read.csv("../Figures/cell_line_label_colors.csv",
stringsAsFactors = FALSE)
# load the data --------
# define an empty named list for storing data
data <- setNames(vector("list", length(features)), features)
for (f in features){
data[[f]] <- read_tsv(paste('../data/',f,'.tsv',sep = ''),
show_col_types = FALSE) %>% as_tibble()
colnames(data[[f]]) <- c("cl_id", "sub_id", "feature_value")
data[[f]] <- data[[f]] %>%
mutate_at(c('cl_id', 'sub_id'), as.factor)
}
# Count the number of measurements -----
counts <- setNames(vector("list", length(features)), features)
for (f in features){
counts[[f]] <- data[[f]] %>%
group_by(cl_id, sub_id) %>%
summarise(n = n()) %>%
ungroup() %>%
# pivot to wider
pivot_wider(names_from = sub_id, values_from = n) %>%
# make cl_id factor with levels in the order of cell.line.names
mutate(cl_id = factor(cl_id, levels = cell.line.names$cl_id)) %>%
arrange(cl_id) %>%
# make cl_id to rownames
column_to_rownames(var = "cl_id")
}
# Compare the counts for area, aspect ratio, and circularity ----
# expect them to be the same for all cell line-substrate pairs
if (sum(counts[["area"]] != counts[["aspect_ratio"]]) != 0 |
sum(counts[["area"]] != counts[["circularity"]]) != 0){
message("The counts for area, aspect ratio, and circularity are NOT same for all cell line-substrate pairs")
} else {
message("The counts for area, aspect ratio, and circularity are same for all cell line-substrate pairs")
}
?kable
# save the counts as a latex table -------
for (f in c("area", "cell_stiffness", "motility")){
counts[[f]] |>
kable(
format = "latex",
align = "c",
caption = "",
label = paste("count-", f),
booktabs = TRUE,
linesep = "",
escape = FALSE
) |>
kable_styling(latex_options = "hold_position") |>
save_kable(paste0("supplementary_table_", f, ".tex"))
}
View(cell.line.names)
# global parameters -------
features <- c("area", "circularity", "aspect_ratio",
"cell_stiffness", "motility")
cell.line.names <-  read.csv("../Figures/cell_line_label_colors.csv",
stringsAsFactors = FALSE) %>%
select(cl_id, label)
# load the data --------
# define an empty named list for storing data
data <- setNames(vector("list", length(features)), features)
for (f in features){
data[[f]] <- read_tsv(paste('../data/',f,'.tsv',sep = ''),
show_col_types = FALSE) %>% as_tibble()
colnames(data[[f]]) <- c("cl_id", "sub_id", "feature_value")
data[[f]] <- data[[f]] %>%
mutate_at(c('cl_id', 'sub_id'), as.factor)
}
# Count the number of measurements -----
counts <- setNames(vector("list", length(features)), features)
for (f in features){
counts[[f]] <- data[[f]] %>%
group_by(cl_id, sub_id) %>%
summarise(n = n()) %>%
ungroup() %>%
# pivot to wider
pivot_wider(names_from = sub_id, values_from = n) %>%
# join with cell.line.names to get the cell line labels
left_join(cell.line.names, by = "cl_id") %>%
# make cl_id factor with levels in the order of cell.line.names
mutate(cl_id = factor(cl_id, levels = cell.line.names$cl_id)) %>%
arrange(cl_id) %>%
select(-cl_id) %>%
# make cl_id to rownames
column_to_rownames(var = "label")
}
# Compare the counts for area, aspect ratio, and circularity ----
# expect them to be the same for all cell line-substrate pairs
if (sum(counts[["area"]] != counts[["aspect_ratio"]]) != 0 |
sum(counts[["area"]] != counts[["circularity"]]) != 0){
message("The counts for area, aspect ratio, and circularity are NOT same for all cell line-substrate pairs")
} else {
message("The counts for area, aspect ratio, and circularity are same for all cell line-substrate pairs")
}
# save the counts as a latex table -------
for (f in c("area", "cell_stiffness", "motility")){
counts[[f]] |>
kable(
format = "latex",
align = "c",
caption = "",
label = paste("count-", f),
booktabs = TRUE,
linesep = "",
escape = FALSE
) |>
kable_styling(latex_options = "hold_position") |>
save_kable(paste0("supplementary_table_", f, ".tex"))
}
